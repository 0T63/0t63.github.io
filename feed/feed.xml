<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet href="pretty-atom-feed.xsl" type="text/xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  <title>Blog Title</title>
  <subtitle>This is a longer description about your blog.</subtitle>
  <link href="https://example.com/feed/feed.xml" rel="self" />
  <link href="https://example.com/" />
  <updated>2026-01-30T00:00:00Z</updated>
  <id>https://example.com/</id>
  <author>
    <name>Your Name</name>
  </author>
  <entry>
    <title>一些瑣碎的思考</title>
    <link href="https://example.com/blog/2026-01-30/" />
    <updated>2026-01-30T00:00:00Z</updated>
    <id>https://example.com/blog/2026-01-30/</id>
    <content type="html">&lt;h2 id=&quot;01-49&quot; tabindex=&quot;-1&quot;&gt;01点49分 &lt;a class=&quot;header-anchor&quot; href=&quot;https://example.com/blog/2026-01-30/#01-49&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;花了一會把ThinkPad X220刷了個 Lubuntu 有一説一這UI看著是挺廉價的,今天沒做什麽有意義的事,就單純刷完之後配置了一些遠程 SSH 需要的工具,openssh-server,tailscale,還有個git.都沒啥技術含量,簡單地把X220改裝成了隨時準備的技術節點…以後出遠門有帶著它的理由了&lt;/p&gt;
&lt;p&gt;今天沒什麽好寫的,就這樣吧.今天甚至都沒稍微學點有用的,本來還想著看會DOM呢&lt;/p&gt;
&lt;p&gt;説實在的了唔講的好像真有,刷完機之後我本來是準備先鏈接互聯網的,結果打不開無綫網木結構是這死媽的二手電腦販子把無綫模塊給扣了.這立即電池也是用不了的,這還賣我爸200.我都無語…看了一下bios確認只能有綫鏈接路由,還好旁邊有網綫.能上網…本來準備安裝個code GUI,結果發現CPU的運行庫太老貌似不行,如果我想要帶這個出去那只能Vim編程了hhhh.遂放棄,然後還有件事是裝tailscale,貌似因爲網絡被墻了的原因,如果我想連接還要給這臺電腦裝個VPN,這種電腦如果相裝GUI還是算了,命令行VPN吧.但是我改主意了,我準備把這臺電腦當作本地計算節點,如果VPS挂了本地還有這玩意救急不是? ^259d4e&lt;/p&gt;
&lt;p&gt;那麽我想出來一個新點子,樹莓派支持以太網直連嗎?我預先把鏡像先下載到樹莓派裏,環境都預先配置好,微型電源什麽的,還有Linux.到時候在外面比如咖啡館,VPS挂掉的情況下能不能靠這種方式繼續產出?&lt;/p&gt;
&lt;p&gt;這是個好主意…我會試試的.目前X220計劃已經告一段落.可以試試樹莓派了[[備忘錄]]&lt;/p&gt;
&lt;p&gt;目前的計劃是把樹莓派改裝成類似本地GitHub workflow,剛才我已經説了,預裝依賴環境…&lt;/p&gt;
&lt;h2 id=&quot;02-21&quot; tabindex=&quot;-1&quot;&gt;02点21分 &lt;a class=&quot;header-anchor&quot; href=&quot;https://example.com/blog/2026-01-30/#02-21&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我是不是忘了講手機的進度了?很遺憾的事情是,我的手機目前並不能解鎖bootloader,一方面OPPO廠商極度不配合,很少有人試過我這個機型.我妥協了,所以我去嘗試了termux,但是效果也不盡人意.只能先放棄了. [[2026-01-29#02点48分]]&lt;/p&gt;
&lt;h2 id=&quot;15-46&quot; tabindex=&quot;-1&quot;&gt;15点46分 &lt;a class=&quot;header-anchor&quot; href=&quot;https://example.com/blog/2026-01-30/#15-46&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我瞭解到了NixOS這一Linux發行版,我感覺挺不錯的,它做到了原子級回滾,不是修改會和三年前相似的配置,為是完全回到那個時候的系統狀態,系統層面不會有一個字節的差距hh,但問題是學習曲綫很陡峭,畢竟比較的反直覺,但是如果熟悉了就很舒服了.&lt;/p&gt;
&lt;p&gt;我會考慮試試的,加入備忘錄[[備忘錄]]&lt;/p&gt;
&lt;h2 id=&quot;17-13&quot; tabindex=&quot;-1&quot;&gt;17点13分 &lt;a class=&quot;header-anchor&quot; href=&quot;https://example.com/blog/2026-01-30/#17-13&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我在花時間瞭解Docker與Nix的理念, Dockerfile 本身是命令式的,按顺序跑,你的最终结果依赖于&lt;strong&gt;运行时环境的状态&lt;/strong&gt;,也就是隐含的时间变量(apt 仓库什么时候更新,基础镜像什么时候改变). Nix 类似于给这个过程加了“&lt;strong&gt;不可变的时间点锁&lt;/strong&gt;”:每个依赖,每个源,每个构建步骤都有&lt;strong&gt;精确的哈希锁定&lt;/strong&gt;.即使你再重建,也会严格按这个快照来取依赖,不会受时间或仓库更新的影响.&lt;/p&gt;
&lt;p&gt;先講講dockerfile&lt;/p&gt;
&lt;pre class=&quot;language-dockerfile&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-dockerfile&quot;&gt;&lt;span class=&quot;token instruction&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;FROM&lt;/span&gt; ubuntu:22.04&lt;/span&gt;
&lt;span class=&quot;token instruction&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;RUN&lt;/span&gt; apt-get update &amp;amp;&amp;amp; apt-get install -y curl gcc&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里隐藏了一个不透明输入:&lt;br&gt;
“apt 仓库在 build 那一刻的状态”.&lt;br&gt;
這個狀態本來應該是固定的.但 docker 選擇了不去管,不過也不能這麽説,我查了一下資料.Docker 的设计目标从来不是“完美可复现”,而是“足够一致,足够方便,足够可分发”.很多 Docker 使用问题，貌似可以通过固定 digest,使用 lockfile,私有镜像仓库来缓解,只是 Docker 默认不强迫你这么做,而 Nix 是“你不这么做就没法用”.&lt;/p&gt;
&lt;p&gt;貌似就是因爲&amp;quot;Docker 默认不强迫你这么做&amp;quot;,很多官方鏡像通常不鎖 digest,也不鎖 apt 包版本,所以重複 build 的不確定性還是比Nix高…查了查資料,還有細節原因,但是由於我現在還沒體驗過 Nix,并不能很好的瞭解到.&lt;/p&gt;
&lt;pre class=&quot;language-doc&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-doc&quot;&gt;
**过程仍然命令式**：即使锁了版本，你的 Dockerfile 还是一条条 RUN 命令，未来 build 的顺序、缓存、构建参数仍可能影响结果。

**闭包不完整**：Docker 不会自动追踪依赖的依赖，也不会帮你计算依赖图，像 Nix 那种**每个包的 hash 都被追踪**、形成闭包的机制，Docker 做不到原生

Nix 的核心设计目标是：

- **完美可复现**：build 输入唯一决定输出，任何未来重建必然一致。

- **全依赖闭包**：一个 derivation 会追踪自己所有依赖的 hash，包括依赖的依赖，形成完整闭包。

- **时间不是变量**：Nix 构建与构建时间无关，外部世界变化不会破坏可复现性。

  - Docker + 固定 digest / lockfile / 私有仓库 → “尽力复现，仍是工程约束”，它解决的是**实际使用的便利性与可控性**。

- Nix → “数学式可复现”，它从系统设计角度定义了因果，**你不需要额外去记住每条约束**。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或許哪天我在用Nix時意識到,我已經三個月沒有修復過環境依賴,我才會意識到 Nix / NixOS 有多好用 哈哈哈&lt;/p&gt;
&lt;p&gt;先這樣吧,看會書,最近都沒怎麽看過書了,挪威的森林還沒看完…&lt;/p&gt;
</content>
  </entry>
</feed>